using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace PrepatcherCodeGenerator;

[Generator]
public class PlayerDataAccessGenerator : ISourceGenerator
{
    private bool IsValidField(IFieldSymbol symbol)
    {
        if (symbol.IsStatic || symbol.IsReadOnly)
        {
            return false;
        }

        if (symbol.DeclaredAccessibility != Accessibility.Public)
        {
            return false;
        }
        // We assume that the publicizer doesn't make things non-public, so we don't need to check the attribute param
        if (symbol.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == "BepInEx.AssemblyPublicizer.OriginalAttributesAttribute"))
        {
            return false;
        }
        // We would like to skip NonSerialized fields but the symbol.GetAttributes() doesn't seem to include NonSerialized

        return true;
    }

    private void GetAccessorStrings(IFieldSymbol symbol, out string typeName, out string getAccessor, out string setAccessor)
    {
        if (symbol.Type.SpecialType == SpecialType.System_String)
        {
            typeName = "string";
            getAccessor = "GetString";
            setAccessor = "SetString";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Boolean)
        {
            typeName = "bool";
            getAccessor = "GetBool";
            setAccessor = "SetBool";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Single)
        {
            typeName = "float";
            getAccessor = "GetFloat";
            setAccessor = "SetFloat";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Int32)
        {
            typeName = "int";
            getAccessor = "GetInt";
            setAccessor = "SetInt";
            return;
        }
        else if (symbol.Type.Name == "Vector3")
        {
            typeName = "Vector3";
            getAccessor = "GetVector3";
            setAccessor = "SetVector3";
            return;
        }

        typeName = symbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        getAccessor = $"GetVariable<{typeName}>";
        setAccessor = $"SetVariable<{typeName}>";
    }

    public void Execute(GeneratorExecutionContext context)
    {
        Compilation compilation = context.Compilation;
        INamespaceOrTypeSymbol playerDataSymbol = compilation.GlobalNamespace.GetMembers("PlayerData")
            .FirstOrDefault(t => t.Kind == SymbolKind.NamedType && t.DeclaredAccessibility == Accessibility.Public);

        if (playerDataSymbol == null)
        {
            throw new Exception("Could not find PlayerData");
        }

        List<IFieldSymbol> fieldsToDelegate = playerDataSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(IsValidField)
            .ToList();

        StringBuilder sb = new();
        sb.Append($@"
// <auto-generated/>
using System;
using TeamCherry.SharedUtils;
using UnityEngine;

namespace PrepatcherPlugin;

// This class is generated at build time by PlayerDataAccessGenerator.
// It proxies access to bool fields on PlayerData using GetBool/SetBool.
public static partial class PlayerDataAccess
{{
");

        foreach (IFieldSymbol field in fieldsToDelegate)
        {
            string fieldName = field.Name;
            GetAccessorStrings(field, out string typeName, out string getAccessor, out string setAccessor);

            // Generate the static property:
            sb.Append($@"
    /// <summary>
    /// Accessor for the PlayerData field: {fieldName}
    /// </summary>
    public static {typeName} {fieldName}
    {{
        get => PlayerData.instance.{getAccessor}(""{fieldName}"");
        set => PlayerData.instance.{setAccessor}(""{fieldName}"", value);
    }}
");
        }

        sb.Append(@"}");

        context.AddSource("PlayerDataAccess.g.cs", sb.ToString());
    }

    public void Initialize(GeneratorInitializationContext context) { }
    
}
