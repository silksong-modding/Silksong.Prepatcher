using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;

namespace PrepatcherCodeGenerator;

[Generator]
public class PlayerDataAccessGenerator : IIncrementalGenerator
{
    [SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking", Justification = "No release")]
    private static readonly DiagnosticDescriptor noPlayerDataDescriptor = new(
        id: "PDA001",
        title: "Player Data Missing",
        messageFormat: "Could not find the PlayerData symbol in the compilation. The generator cannot run.",
        category: "SourceGeneration",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    /// <summary>
    /// Returns true if symbol represents a field that is marked as having originally been nonpublic by the
    /// bepinex publicizer.
    /// </summary>
    private bool WasNonPublic(IFieldSymbol symbol)
    {
        IEnumerable<AttributeData> bepInExAttrs = symbol
            .GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "BepInEx.AssemblyPublicizer.OriginalAttributesAttribute");

        foreach (AttributeData attr in bepInExAttrs)
        {
            if (attr.ConstructorArguments.Length > 0 &&
                attr.ConstructorArguments[0].Value is int val &&
                val != (int)FieldAttributes.Public)
            {
                return true;
            }
        }

        return false;
    }

    private bool IsValidField(IFieldSymbol symbol)
    {
        if (symbol.IsStatic || symbol.IsReadOnly)
        {
            return false;
        }

        if (symbol.DeclaredAccessibility != Accessibility.Public)
        {
            return false;
        }
        if (WasNonPublic(symbol))
        {
            return false;
        }
        // We would like to skip NonSerialized fields but the symbol.GetAttributes() doesn't seem to include NonSerialized
        // That said, nothing should break if GetBool/whatever is applied to a NonSerialized public field so this is fine
        // to include.

        return true;
    }

    private void GetAccessorStrings(IFieldSymbol symbol, out string typeName, out string getAccessor, out string setAccessor)
    {
        if (symbol.Type.SpecialType == SpecialType.System_String)
        {
            typeName = "string";
            getAccessor = "GetString";
            setAccessor = "SetString";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Boolean)
        {
            typeName = "bool";
            getAccessor = "GetBool";
            setAccessor = "SetBool";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Single)
        {
            typeName = "float";
            getAccessor = "GetFloat";
            setAccessor = "SetFloat";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Int32)
        {
            typeName = "int";
            getAccessor = "GetInt";
            setAccessor = "SetInt";
            return;
        }
        else if (symbol.Type.Name == "Vector3")
        {
            typeName = "Vector3";
            getAccessor = "GetVector3";
            setAccessor = "SetVector3";
            return;
        }

        typeName = symbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        getAccessor = $"GetVariable<{typeName}>";
        setAccessor = $"SetVariable<{typeName}>";
    }

    private string GenerateSourceText(ITypeSymbol playerDataSymbol)
    {
        List<IFieldSymbol> fieldsToDelegate = playerDataSymbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(IsValidField)
            .ToList();

        StringBuilder sb = new();
        sb.Append($$"""
            // <auto-generated/>
            using System;
            using TeamCherry.SharedUtils;
            using UnityEngine;

            namespace PrepatcherPlugin;

            // This class is generated at build time by PlayerDataAccessGenerator.
            // It proxies access to bool fields on PlayerData using GetBool/SetBool.
            public static partial class PlayerDataAccess
            {
            """);

        foreach (IFieldSymbol field in fieldsToDelegate)
        {
            string fieldName = field.Name;
            GetAccessorStrings(field, out string typeName, out string getAccessor, out string setAccessor);

            sb.Append($$"""

                /// <summary>
                /// Accessor for the PlayerData field: {{fieldName}}
                /// </summary>
                public static {{typeName}} {{fieldName}}
                {
                    get => PlayerData.instance.{{getAccessor}}(nameof(PlayerData.{{fieldName}}));
                    set => PlayerData.instance.{{setAccessor}}(nameof(PlayerData.{{fieldName}}), value);
                }

            """);
        }

        sb.Append("}\n");

        return sb.ToString();
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<INamespaceOrTypeSymbol> playerDataProvider = context
            .CompilationProvider
            .Select(
                (compilation, _) => compilation.GlobalNamespace.GetMembers("PlayerData")
                .FirstOrDefault(t => t.Kind == SymbolKind.NamedType && t.DeclaredAccessibility == Accessibility.Public));

        context.RegisterSourceOutput(playerDataProvider, (spc, playerDataSymbol) =>
        {
            if (playerDataSymbol is not ITypeSymbol playerDataTypeSymbol)
            {
                spc.ReportDiagnostic(Diagnostic.Create(noPlayerDataDescriptor, Location.None));
                return;
            }

            spc.AddSource("PlayerDataAccess.g.cs", GenerateSourceText(playerDataTypeSymbol));
        });
    }
}
