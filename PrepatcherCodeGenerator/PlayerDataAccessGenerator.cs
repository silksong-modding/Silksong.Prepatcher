using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;

namespace PrepatcherCodeGenerator;

[Generator]
public class PlayerDataAccessGenerator : IIncrementalGenerator
{
    [SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking", Justification = "No release")]
    private static readonly DiagnosticDescriptor noPlayerDataDescriptor = new(
        id: "PDA001",
        title: "Player Data Missing",
        messageFormat: "Could not find the PlayerData symbol in the compilation. The generator cannot run.",
        category: "SourceGeneration",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private record PDFieldData(string FieldName, string TypeName, string GetAccessor, string SetAccessor);

    private record TypeData(string TypeName, string GetAccessorName, string SetAccessorName, string shortType);

    /// <summary>
    /// Returns true if symbol represents a field that is marked as having originally been nonpublic by the
    /// bepinex publicizer.
    /// </summary>
    private bool WasNonPublic(IFieldSymbol symbol)
    {
        IEnumerable<AttributeData> bepInExAttrs = symbol
            .GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "BepInEx.AssemblyPublicizer.OriginalAttributesAttribute");

        foreach (AttributeData attr in bepInExAttrs)
        {
            if (attr.ConstructorArguments.Length > 0 &&
                attr.ConstructorArguments[0].Value is int val &&
                val != (int)FieldAttributes.Public)
            {
                return true;
            }
        }

        return false;
    }

    private bool IsValidField(IFieldSymbol symbol)
    {
        if (symbol.IsStatic || symbol.IsReadOnly)
        {
            return false;
        }

        if (symbol.DeclaredAccessibility != Accessibility.Public)
        {
            return false;
        }
        if (WasNonPublic(symbol))
        {
            return false;
        }
        // We would like to skip NonSerialized fields but the symbol.GetAttributes() doesn't seem to include NonSerialized
        // That said, nothing should break if GetBool/whatever is applied to a NonSerialized public field so this is fine
        // to include.

        return true;
    }

    private void GetAccessorStrings(IFieldSymbol symbol, out string typeName, out string getAccessor, out string setAccessor)
    {
        if (symbol.Type.SpecialType == SpecialType.System_String)
        {
            typeName = "string";
            getAccessor = "GetString";
            setAccessor = "SetString";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Boolean)
        {
            typeName = "bool";
            getAccessor = "GetBool";
            setAccessor = "SetBool";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Single)
        {
            typeName = "float";
            getAccessor = "GetFloat";
            setAccessor = "SetFloat";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Int32)
        {
            typeName = "int";
            getAccessor = "GetInt";
            setAccessor = "SetInt";
            return;
        }
        else if (symbol.Type.Name == "Vector3")
        {
            typeName = "Vector3";
            getAccessor = "GetVector3";
            setAccessor = "SetVector3";
            return;
        }

        typeName = symbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        getAccessor = $"GetVariable<{typeName}>";
        setAccessor = $"SetVariable<{typeName}>";
    }

    private PDFieldData ToData(IFieldSymbol symbol)
    {
        GetAccessorStrings(symbol, out string typeName, out string getAccessor, out string setAccessor);
        return new(symbol.Name, typeName, getAccessor, setAccessor);
    }
    
    private string GenerateAccessSourceText(IReadOnlyList<PDFieldData> fieldsToDelegate)
    {
        StringBuilder sb = new();
        sb.Append($$"""
            // <auto-generated/>
            using System;
            using TeamCherry.SharedUtils;
            using UnityEngine;

            namespace PrepatcherPlugin;

            public static partial class PlayerDataAccess
            {
            """);

        foreach (PDFieldData field in fieldsToDelegate)
        {
            sb.Append($$"""

                /// <summary>
                /// Accessor for the PlayerData field: {{field.FieldName}}
                /// </summary>
                public static {{field.TypeName}} {{field.FieldName}}
                {
                    get => PlayerData.instance.{{field.GetAccessor}}(nameof(PlayerData.{{field.FieldName}}));
                    set => PlayerData.instance.{{field.SetAccessor}}(nameof(PlayerData.{{field.FieldName}}), value);
                }

            """);
        }

        sb.Append("}\n");

        return sb.ToString();
    }

    private string GenerateInternalSourceText(IReadOnlyList<PDFieldData> pdFields)
    {
        StringBuilder sb = new();
        sb.Append($$"""
            // <auto-generated/>
            using System;
            using TeamCherry.SharedUtils;
            using UnityEngine;

            namespace PrepatcherPlugin;

            public static partial class PlayerDataInternal
            {
            """);
        sb.AppendLine();

        Dictionary<string, TypeData> accessTypes = new()
        {
            ["bool"] = new("bool", "GetBool", "SetBool", "bool"),
            ["int"] = new("int", "GetInt", "SetInt", "int"),
            ["string"] = new("string", "GetString", "SetString", "string"),
            ["float"] = new("float", "GetFloat", "SetFloat", "float"),
        };

        Dictionary<string, StringBuilder> GetStringBuilders = accessTypes.Keys.ToDictionary(x => x, x => new StringBuilder());
        Dictionary<string, StringBuilder> SetStringBuilders = accessTypes.Keys.ToDictionary(x => x, x => new StringBuilder());

        foreach ((string typeName, StringBuilder getSb) in GetStringBuilders)
        {
            TypeData td = accessTypes[typeName];
            getSb.AppendLine("/// <summary>");
            getSb.AppendLine($"/// Internal get accessor for fields of type {typeName}");
            getSb.AppendLine("/// </summary>");
            getSb.AppendLine($"    public static {td.TypeName} {td.GetAccessorName}(PlayerData pd, string {td.shortType}Name)");
            getSb.AppendLine("    {");
            getSb.AppendLine($"        switch ({td.shortType}Name)");
            getSb.AppendLine("        {");
        }

        foreach ((string typeName, StringBuilder setSb) in SetStringBuilders)
        {
            TypeData td = accessTypes[typeName];
            setSb.AppendLine("/// <summary>");
            setSb.AppendLine($"/// Internal set accessor for fields of type {typeName}");
            setSb.AppendLine("/// </summary>");
            setSb.AppendLine($"    public static void {td.SetAccessorName}(PlayerData pd, string {td.shortType}Name, {td.TypeName} value)");
            setSb.AppendLine("    {");
            setSb.AppendLine($"        switch ({td.shortType}Name)");
            setSb.AppendLine("        {");
        }

        foreach (PDFieldData field in pdFields)
        {
            if (accessTypes.TryGetValue(field.TypeName, out TypeData td))
            {
                StringBuilder getSb = GetStringBuilders[field.TypeName];
                StringBuilder setSb = SetStringBuilders[field.TypeName];

                getSb.AppendLine($"            case nameof(PlayerData.{field.FieldName}):");
                getSb.AppendLine($"                return pd.{field.FieldName};");

                setSb.AppendLine($"            case nameof(PlayerData.{field.FieldName}):");
                setSb.AppendLine($"                pd.{field.FieldName} = value;");
                setSb.AppendLine($"                return;");
            }
        }

        foreach (StringBuilder getSb in GetStringBuilders.Values)
        {
            getSb.AppendLine("            default:");
            getSb.AppendLine("                return default;");
            getSb.AppendLine("        }");
            getSb.AppendLine("    }");
        }

        foreach (StringBuilder setSb in SetStringBuilders.Values)
        {
            setSb.AppendLine("            default:");
            setSb.AppendLine("                return;");
            setSb.AppendLine("        }");
            setSb.AppendLine("    }");
        }

        foreach (string key in accessTypes.Keys)
        {
            sb.Append(GetStringBuilders[key].ToString());
            sb.AppendLine();
            sb.Append(SetStringBuilders[key].ToString());
            sb.AppendLine();
        }

        sb.Append("}\n");

        return sb.ToString();
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<INamespaceOrTypeSymbol> playerDataProvider = context
            .CompilationProvider
            .Select(
                (compilation, _) => compilation.GlobalNamespace.GetMembers("PlayerData")
                .FirstOrDefault(t => t.Kind == SymbolKind.NamedType && t.DeclaredAccessibility == Accessibility.Public));

        IncrementalValueProvider<ImmutableArray<PDFieldData>> fieldDatasProvider = playerDataProvider
            .SelectMany((pd, _) => pd.GetMembers())
            .Where(m => m is IFieldSymbol symb && IsValidField(symb))
            .Select((symb, _) => ToData((IFieldSymbol)symb))
            .Collect();

        context.RegisterImplementationSourceOutput(fieldDatasProvider, (spc, fieldDatas) =>
        {
            spc.AddSource("PlayerDataAccess.g.cs", GenerateAccessSourceText(fieldDatas));
        });

        context.RegisterImplementationSourceOutput(fieldDatasProvider, (spc, fieldDatas) =>
        {
            spc.AddSource("PlayerDataInternal.g.cs", GenerateInternalSourceText(fieldDatas));
        });
    }
}
