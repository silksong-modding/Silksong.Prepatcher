using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Text;

namespace PrepatcherCodeGenerator;

[Generator]
public class PlayerDataAccessGenerator : IIncrementalGenerator
{
    [SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking", Justification = "No release")]
    private static readonly DiagnosticDescriptor noPlayerDataDescriptor = new(
        id: "PDA001",
        title: "Player Data Missing",
        messageFormat: "Could not find the PlayerData symbol in the compilation. The generator cannot run.",
        category: "SourceGeneration",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private record PDFieldData(string FieldName, string TypeName, string GetAccessor, string SetAccessor);

    /// <summary>
    /// Returns true if symbol represents a field that is marked as having originally been nonpublic by the
    /// bepinex publicizer.
    /// </summary>
    private bool WasNonPublic(IFieldSymbol symbol)
    {
        IEnumerable<AttributeData> bepInExAttrs = symbol
            .GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "BepInEx.AssemblyPublicizer.OriginalAttributesAttribute");

        foreach (AttributeData attr in bepInExAttrs)
        {
            if (attr.ConstructorArguments.Length > 0 &&
                attr.ConstructorArguments[0].Value is int val &&
                val != (int)FieldAttributes.Public)
            {
                return true;
            }
        }

        return false;
    }

    private bool IsValidField(IFieldSymbol symbol)
    {
        if (symbol.IsStatic || symbol.IsReadOnly)
        {
            return false;
        }

        if (symbol.DeclaredAccessibility != Accessibility.Public)
        {
            return false;
        }
        if (WasNonPublic(symbol))
        {
            return false;
        }
        // We would like to skip NonSerialized fields but the symbol.GetAttributes() doesn't seem to include NonSerialized
        // That said, nothing should break if GetBool/whatever is applied to a NonSerialized public field so this is fine
        // to include.

        return true;
    }

    private void GetAccessorStrings(IFieldSymbol symbol, out string typeName, out string getAccessor, out string setAccessor)
    {
        if (symbol.Type.SpecialType == SpecialType.System_String)
        {
            typeName = "string";
            getAccessor = "GetString";
            setAccessor = "SetString";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Boolean)
        {
            typeName = "bool";
            getAccessor = "GetBool";
            setAccessor = "SetBool";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Single)
        {
            typeName = "float";
            getAccessor = "GetFloat";
            setAccessor = "SetFloat";
            return;
        }
        else if (symbol.Type.SpecialType == SpecialType.System_Int32)
        {
            typeName = "int";
            getAccessor = "GetInt";
            setAccessor = "SetInt";
            return;
        }
        else if (symbol.Type.Name == "Vector3")
        {
            typeName = "Vector3";
            getAccessor = "GetVector3";
            setAccessor = "SetVector3";
            return;
        }

        typeName = symbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        getAccessor = $"GetVariable<{typeName}>";
        setAccessor = $"SetVariable<{typeName}>";
    }

    private PDFieldData ToData(IFieldSymbol symbol)
    {
        GetAccessorStrings(symbol, out string typeName, out string getAccessor, out string setAccessor);
        return new(symbol.Name, typeName, getAccessor, setAccessor);
    }
    
    private string GenerateAccessSourceText(IReadOnlyList<PDFieldData> fieldsToDelegate)
    {
        StringBuilder sb = new();
        sb.Append($$"""
            // <auto-generated/>
            using System;
            using TeamCherry.SharedUtils;
            using UnityEngine;

            namespace PrepatcherPlugin;

            // This class is generated at build time by PlayerDataAccessGenerator.
            // It proxies access to bool fields on PlayerData using GetBool/SetBool.
            public static partial class PlayerDataAccess
            {
            """);

        foreach (PDFieldData field in fieldsToDelegate)
        {
            sb.Append($$"""

                /// <summary>
                /// Accessor for the PlayerData field: {{field.FieldName}}
                /// </summary>
                public static {{field.TypeName}} {{field.FieldName}}
                {
                    get => PlayerData.instance.{{field.GetAccessor}}(nameof(PlayerData.{{field.FieldName}}));
                    set => PlayerData.instance.{{field.SetAccessor}}(nameof(PlayerData.{{field.FieldName}}), value);
                }

            """);
        }

        sb.Append("}\n");

        return sb.ToString();
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<INamespaceOrTypeSymbol> playerDataProvider = context
            .CompilationProvider
            .Select(
                (compilation, _) => compilation.GlobalNamespace.GetMembers("PlayerData")
                .FirstOrDefault(t => t.Kind == SymbolKind.NamedType && t.DeclaredAccessibility == Accessibility.Public));

        IncrementalValueProvider<ImmutableArray<PDFieldData>> fieldDatasProvider = playerDataProvider
            .SelectMany((pd, _) => pd.GetMembers())
            .Where(m => m is IFieldSymbol symb && IsValidField(symb))
            .Select((symb, _) => ToData((IFieldSymbol)symb))
            .Collect();

        context.RegisterImplementationSourceOutput(fieldDatasProvider, (spc, fieldDatas) =>
        {
            spc.AddSource("PlayerDataAccess.g.cs", GenerateAccessSourceText(fieldDatas));
        });
    }
}
